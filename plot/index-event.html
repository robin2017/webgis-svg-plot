<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SVG标绘</title>
</head>
<body>
<header>
    <h1>SVG标绘</h1>
</header>

<div class="body-wrapper">
    <aside>
        <section class="title">
            <h2>军标列表</h2>
            <button class="cancel">取消标绘</button>
        </section>
        <section class="list">
            <h3 class="item-title">点军标</h3>
            <ul class="item-ul">
                <li>
                    <div class="icon-unit">
                        <img src="icon/point/fly.svg" class="icon-content" alt="飞机">
                        <div>飞机</div>
                    </div>
                </li>
                <li>
                    <div class="icon-unit">
                        <img src="icon/point/people.svg" class="icon-content" alt="飞机">
                        <div>人员</div>
                    </div>
                </li>
                <li>
                    <div class="icon-unit">
                        <img src="icon/point/ship.svg" class="icon-content" alt="飞机">
                        <div>船只</div>
                    </div>
                </li>
            </ul>

            <h3 class="item-title">线面军标</h3>
            <ul class="item-ul">
                <li>
                    <div class="icon-unit">
                        <img src="icon/xm/line.svg" class="icon-content" alt="飞机">
                        <div>线段</div>
                    </div>
                </li>
                <li>
                    <div class="icon-unit">
                        <img src="icon/xm/circle.svg" class="icon-content" alt="飞机">
                        <div>圆</div>
                    </div>
                </li>
                <li>
                    <div class="icon-unit">
                        <img src="icon/xm/rect.svg" class="icon-content" alt="飞机">
                        <div>矩形</div>
                    </div>
                </li>
            </ul>
        </section>
    </aside>
    <main>
        <svg id="plotBoard" width="100%" height="100%">

        </svg>
    </main>
</div>
<div id="svg-lib" style="height:0;"></div>

<script src="svgUtils.js"></script>
<script>
    console.log('完成svg-lib加载');
    loadSvg('#svg-lib', './icon/point/point-lib.svg')
</script>
<script>
    let plotTargetPath = null;
    const plotBoard = document.querySelector('#plotBoard');
    const plotLib = document.querySelector('#svg-lib');
    const translateRegEx = /translate\((.*?),(.*?)\)/;
    const scaleRegEx = /scale\((.*?),(.*?)\)/;
    const rotateRegEx = /rotate\((.*?)\)/;
    //全局变量
    let svgLeft = null, svgTop = null;


    //拖拽相关变量
    let dragTarget = null, dragTargetX = null, dragTargetY = null,
        dragTargetClientX = null, dragTargetClientY = null;


    function dragStart(evt) {
        dragTarget = getEditClassNode(evt.target);
        if (dragTarget === null) return false;
        console.log('dragStart');
        dragTargetClientX = evt.clientX;
        dragTargetClientY = evt.clientY;
        let {ret} = getTransformRegValue(dragTarget, 'translate');
        console.log(ret[0]);
        if (ret !== null) {//肯定有
            dragTargetX = parseFloat(ret[1]);
            dragTargetY = parseFloat(ret[2]);
            console.log('dragStart:', dragTarget, dragTargetX, dragTargetY, dragTargetClientX, dragTargetClientY)
        }
        return true;
    }

    function dragMove(evt) {
        if (dragTarget === null) return false;
        console.log('dragMove');
        let dx = evt.clientX - dragTargetClientX;
        let dy = evt.clientY - dragTargetClientY;
        let {transform, ret} = getTransformRegValue(dragTarget, 'translate');
        let translateBefore = ret[0];
        let translateAfter = `translate(${dx + dragTargetX},${dy + dragTargetY})`;
        transform = transform.replace(translateBefore, translateAfter);
        console.log('dragMove value:', transform, '/', translateBefore, '/', translateAfter)
        dragTarget.setAttribute('transform', transform)

    }

    function dragEnd(evt) {
        if (dragTarget === null) return false;
        console.log('dragEnd');
        dragTarget = null;
        return true;
    }

    //缩放相关变量
    let scaleTarget = null,
        scaleValueX = null, scaleValueY = null, cx = null, cy = null,

        scaleTargetClientX = null, scaleTargetClientY = null,
        //以下变量有用
        scaleUnitX = null, scaleUnitY = null,
        scaleAngle = null,
        scaleTargetCenterX = null, scaleTargetCenterY = null;

    function scaleStart(evt) {
        let scaleType = isScaleTarget(evt.target)
        if (!scaleType) return false;
        scaleTarget = getEditClassNode(evt.target);
        if (scaleTarget === null) return false;
        console.log('scaleStart');
        cx = scaleUnitX = parseFloat(evt.target.getAttribute('cx'));
        cy = scaleUnitY = parseFloat(evt.target.getAttribute('cy'));
        //3、角度大小

        let {retC} = getTransformRegValue(scaleTarget, 'rotate');
        if (retC !== null) { //肯定不
            scaleAngle = parseFloat(retC[1]);
        }
        //4、缩放比例
        let {ret} = getTransformRegValue(scaleTarget, 'scale');
        if (ret !== null) {
            scaleValueX = parseFloat(ret[1]);
            scaleValueY = parseFloat(ret[2]);
        } else {
            scaleValueX = scaleValueY = 1;
        }

        //1、point的位置
        scaleTargetClientX = evt.clientX;
        scaleTargetClientY = evt.clientY;
        /**
         * 2、center的位置(错误，和角度，scale都有关系)
         * 这个是重点问题
         * 角度:scaleAngle,缩放:scaleValueX,scaleValueY,平移：scaleUnitX,scaleUnitY,终点：scaleTargetClientX,scaleTargetClientY;
         * 求起始点centerX,centerY
         *  计算太麻烦，能力不足，使用全局变量吧
         * */
            //现在的
        let {retCC} = getTransformRegValue(scaleTarget, 'translate');
        let tranX, tranY;
        if (retCC !== null) {//肯定有
            tranX = parseFloat(retCC[1]);
            tranY = parseFloat(retCC[2]);
        }
        scaleTargetCenterX = tranX + svgLeft;
        scaleTargetCenterY = tranY + svgTop;
        console.log('hhhhhhhhh:', scaleTargetCenterX, scaleTargetCenterY,tranX, svgLeft)

        //开始的
        // scaleTargetCenterX = scaleTargetClientX - cx;
        // scaleTargetCenterY = scaleTargetClientY - cy;
        // console.log('jjjjjjjj:', scaleTargetCenterX, scaleTargetCenterY, scaleTargetClientX, cx)

        //5、获取投影
        const {xx, yy} = getProjective({x: scaleTargetCenterX, y: scaleTargetCenterY}, {
            x: scaleTargetClientX,
            y: scaleTargetClientY
        }, scaleAngle)

        console.log('scaleType:', scaleType)
        console.log('point,center的位置：', {x: scaleTargetClientX, y: scaleTargetClientY}, {
            x: scaleTargetCenterX,
            y: scaleTargetCenterY
        })
        console.log('角度，xx，yy,scaleValueX,scaleValueY:', scaleAngle, xx, yy, scaleValueX, scaleValueY);
        scaleUnitX = xx / scaleValueX;
        scaleUnitY = yy / scaleValueY;
        console.log(' scaleUnitX,scaleUnitY:', scaleUnitX, scaleUnitY)
        return true;
        /**
         * 得到变量：
         * 中心点(scaleTargetCenterX,scaleTargetCenterY),
         * 角度scaleAngle,
         * 单位投影(scaleUnitX,scaleUnitY),
         * 后续操作
         * 根据中心点和角度，计算投影，然后与单位投影求比值即可得到scale
         * */
    }

    function scaleMove(evt) {
        if (scaleTarget === null) return false;

        //1、计算投影
        const {xx, yy} = getProjective(
            {
                x: scaleTargetCenterX,
                y: scaleTargetCenterY
            },
            {
                x: evt.clientX,
                y: evt.clientY
            }, scaleAngle);
        let scaleX = xx / scaleUnitX;
        let scaleY = yy / scaleUnitY;
        console.log('现在的缩放比例为：', scaleX, scaleY);
        console.log('scaleMove:', scaleValueX, scaleValueY,
            scaleTargetClientX, scaleTargetClientY);
        // let dx = evt.clientX - scaleTargetClientX;
        // let scaleX = dx / cx + 1;
        // console.log(dx, cx, scaleX);


        let {transform, ret} = getTransformRegValue(scaleTarget, 'scale');

        let scaleBefore = ret[0];
        let scaleAfter = `scale(${scaleX},${scaleY})`;
        transform = transform.replace(scaleBefore, scaleAfter);
        console.log('scaleMove value:', transform, '/', scaleBefore, '/', scaleAfter)
        scaleTarget.setAttribute('transform', transform)
        return true;
    }

    function scaleEnd() {
        if (scaleTarget === null) return false;
        console.log('scaleEnd')
        scaleTarget = null;
        return true;
    }

    //旋转相关变量
    let rotateTarget = null, rotateCx = null, rotateCy = null, initAngle = null,
        rotateClientX, rotateClientY;


    function rotateStart(evt) {
        if (!isRotateTarget(evt.target)) return false;
        rotateTarget = getEditClassNode(evt.target);
        if (rotateTarget === null) return false;
        console.log('rotateStart');

        let {ret} = getTransformRegValue(rotateTarget, 'rotate');

        if (ret !== null) { //肯定不
            initAngle = parseFloat(ret[1]);
        }

        let dis = Math.abs(parseFloat(evt.target.getAttribute('cy')));
        let cx = dis * Math.sin(initAngle * Math.PI / 180);
        let cy = dis * Math.cos(initAngle * Math.PI / 180);
        rotateClientX = evt.clientX;
        rotateClientY = evt.clientY;
        rotateCx = rotateClientX - cx;
        rotateCy = rotateClientY + cy;
        console.log('计算中心点：', rotateClientX, cx, rotateClientY, cy)
        console.log(rotateTarget, rotateCx, rotateCy, rotateClientX, rotateClientY, initAngle)
        return true;
    }

    function rotateMove(evt) {
        if (rotateTarget === null) return false;
        console.log('rotateMove');
        let x = evt.clientX;
        let y = evt.clientY;
        let center = {x: rotateCx, y: rotateCy}, start = {x: rotateClientX, y: rotateClientY}, end = {x, y};
        let dAngle = 0 - getAngle3(center, start, end);

        let {transform, ret} = getTransformRegValue(rotateTarget, 'rotate');


        let rotateBefore = ret[0];
        let rotateAfter = `rotate(${initAngle + dAngle})`;

        console.log('初始角度和差值：', initAngle, dAngle)
        transform = transform.replace(rotateBefore, rotateAfter);
        console.log('scaleMove value:', transform, '/', rotateBefore, '/', rotateAfter)
        rotateTarget.setAttribute('transform', transform)
        return true;
    }

    function rotateEnd(evt) {
        if (rotateTarget === null) return false;
        console.log('rotateEnd');
        rotateTarget = null;
        return true;
    }


    document.querySelector('.body-wrapper > aside .title .cancel')
        .addEventListener('click', function () {
            plotTargetPath = null;
        });
    document.querySelector('.body-wrapper>aside').addEventListener('click', function (evt) {
        if (evt.target.nodeName === 'IMG') {
            let src = evt.target.getAttribute('src');
            let path = src.substring(5, src.length - 4);
            console.log('点击了：', path);
            plotTargetPath = path;
        }
    });

    function plotPointClone(x, y) {
        let target = plotLib.querySelector('#' + plotTargetPath.replace('/', '_'));
        let clone = target.cloneNode(true);
        clone.setAttribute('transform', `translate(${x},${y}) rotate(0) scale(1,1)`);
        plotBoard.appendChild(clone);
    }

    /**
     *PART1:基础函数
     * */
    function getTransformRegValue(target, type) {
        let transform = target.getAttribute("transform");
        let ret = null;
        if (type === 'rotate') {
            ret = rotateRegEx.exec(transform);
        } else if (type === 'scale') {
            ret = scaleRegEx.exec(transform)
        } else if (type === 'translate') {
            ret = translateRegEx.exec(transform)
        } else {
            console.error('reg type 错误')
        }
        let transformC = transform, retC = ret;
        let transformCC = transformC, retCC = retC;
        return {
            transform, ret, transformC, retC, transformCC, retCC
        }
    }

    //元素是不是缩放控制点，不是则为0，控制边点则为1，控制中心点则为2
    function isScaleTarget(ele) {
        let _class = ele.getAttribute('class');
        if (_class !== null && _class.indexOf('control-scale-item') !== -1) {
            if (_class.indexOf('control-scale-vertex') !== -1) {
                return 1;
            } else {
                return 2;
            }
        }
        return 0
    }

    //元素是不是旋转控制点
    function isRotateTarget(ele) {
        let _class = ele.getAttribute('class');
        if (_class !== null && _class.indexOf('control-rotate-item') !== -1) {
            return true
        }
        return false
    }

    //三点坐标求夹角
    function getAngle(center, point) {
        let dx = point.x - center.x;
        let dy = -(point.y - center.y);
        if (dx === 0) {
            if (dy >= 0) {
                return 90;
            } else {
                return 270
            }
        } else if (dx > 0) {
            return Math.atan(dy / dx) * 180 / Math.PI;
        } else {
            return Math.atan(dy / dx) * 180 / Math.PI + 180;
        }
    }

    //一个矢量在另一个矢量上投影
    function getProjective(center, point, alpha) {
        let beta = 90 - alpha;
        //方向也是正确的
        let yy = Math.cos(beta * Math.PI / 180) * (point.x - center.x) +
            Math.sin(beta * Math.PI / 180) * (point.y - center.y);
        let xxz = Math.sqrt(Math.abs(Math.pow(point.x - center.x, 2) +
            Math.pow(point.y - center.y, 2) - Math.pow(yy, 2)));
        let dirVal = Math.pow((point.x - center.x - Math.sin(beta * Math.PI / 180)), 2) +
            Math.pow((point.y - center.y - Math.cos(beta * Math.PI / 180)), 2)
            - 1 - Math.pow(point.x - center.x, 2) - Math.pow(point.y - center.y, 2);
        let xx = xxz * (dirVal > 0 ? -1 : 1);
        return {xx, yy}
    }

    function getAngle3(center, start, end) {
        let angle1 = getAngle(center, end);
        let angle2 = getAngle(center, start);
        console.log('中点，开始点，结束点:', center, start, end, angle1, angle2);
        return angle1 - angle2
    }

    //得到元素的编辑状态
    function getEleState(ele) {
        console.log(ele.nodeName)
        let isActive = ele.getAttribute('class');
        if (isActive !== null && isActive.startsWith("edit")) {
            return isActive
        }
        if (ele.nodeName === 'svg') {
            console.error('该元素没有isEdit属性');
            return 'false'
        }
        return getEleState(ele.parentNode)
    }

    //获取包含edit类型的节点
    function getEditClassNode(ele) {
        let isActive = ele.getAttribute('class');
        if (isActive !== null && isActive.startsWith("edit")) {
            return ele
        }
        if (ele.nodeName === 'svg') {
            return null
        }
        return getEditClassNode(ele.parentNode)
    }

    /**
     * PART0:所有事件统一在plotBoard上进行处理
     * 事件优先级：旋转，缩放，平移
     *
     * */
    plotBoard.addEventListener('click', function (evt) {
        if (plotTargetPath !== null && evt.target.nodeName === "svg") {
            if (!svgLeft || !svgTop) {
                svgLeft = evt.target.getBoundingClientRect().left;
                svgTop = evt.target.getBoundingClientRect().top;
            }
            let x = evt.clientX - evt.target.getBoundingClientRect().left;
            let y = evt.clientY - evt.target.getBoundingClientRect().top;
            // plotPointUse(x, y)
            plotPointClone(x, y)
        } else if (evt.target.nodeName !== "svg" && plotTargetPath === null) {//选中目标，
            console.log('选中目标')
            let target = evt.target;
            if (getEleState(target) === 'edit-inactive') {//状态不可编辑
                let node = getEditClassNode(target);
                node.setAttribute('class', 'edit-active')
            } else if (getEleState(target) === 'edit-active') {//状态可编辑
                //dragStart(evt)
            }
        } else if (plotTargetPath === null && evt.target.nodeName === "svg") {//全部状态不可编辑
            plotBoard.childNodes.forEach(node => {
                node.setAttribute && node.setAttribute('class', "edit-inactive");
            })
        }
    });
    const eventTermination = {};

    function startEvent(type) {
        eventTermination[type] = 1
    }

    function stopEvent(type) {
        eventTermination[type] = 0;
    }

    function isStop(type) {
        return eventTermination[type] === 0
    }

    //第0级：初始化
    plotBoard.addEventListener('mousedown', function (evt) {
        startEvent('mousedown')
    });
    plotBoard.addEventListener('mousemove', function (evt) {
        startEvent('mousemove')
    });
    plotBoard.addEventListener('mouseup', function (evt) {
        startEvent('mouseup')
    });
    //第一级：旋转
    plotBoard.addEventListener('mousedown', function (evt) {
        if (isStop('mousedown')) return;
        if (rotateStart(evt)) stopEvent('mousedown');
    });
    plotBoard.addEventListener('mousemove', function (evt) {
        if (isStop('mousemove')) return;
        if (rotateMove(evt)) stopEvent('mousemove')
    });
    plotBoard.addEventListener('mouseup', function (evt) {
        if (isStop('mouseup')) return;
        if (rotateEnd(evt)) stopEvent('mouseup')
    });
    //第二级别：缩放
    plotBoard.addEventListener('mousedown', function (evt) {
        if (isStop('mousedown')) return;
        if (scaleStart(evt)) stopEvent('mousedown');
    });
    plotBoard.addEventListener('mousemove', function (evt) {
        if (isStop('mousemove')) return;
        if (scaleMove(evt)) stopEvent('mousemove')
    });
    plotBoard.addEventListener('mouseup', function (evt) {
        if (isStop('mouseup')) return;
        if (scaleEnd(evt)) stopEvent('mouseup')

    });
    //第三级别:拖拽,最后优先级，不用stopEvent
    plotBoard.addEventListener('mousedown', function (evt) {
        if (isStop('mousedown')) return;
        if (evt.target.nodeName !== "svg"
            && plotTargetPath === null
            && getEleState(evt.target) === 'edit-active') {
            dragStart(evt)
        }
    });
    plotBoard.addEventListener('mousemove', function (evt) {
        if (isStop('mousemove')) return;
        dragMove(evt);
    });
    plotBoard.addEventListener('mouseup', function (evt) {
        if (isStop('mouseup')) return;
        dragEnd(evt);
    });
</script>
<style>
    * {
        margin: 0;
        padding: 0;
    }

    html, body {
        height: 100%;
    }

    header {
        height: 100px;
        display: flex;
        align-items: center;
        margin-left: 30px;
    }

    .body-wrapper {
        display: flex;
        height: calc(100% - 140px);
        margin: 20px;
    }

    .body-wrapper > aside {
        width: 400px;
        background-color: #ede;
        border-radius: 10px;
    }

    .body-wrapper > aside .title {
        border-bottom: 2px solid lightcoral;
        height: 56px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding-left: 20px;
    }

    .body-wrapper > aside .title .cancel {
        background-color: gray;
        margin-right: 20px;
        padding: 10px;
        border-radius: 10px;
        cursor: pointer;
    }

    .body-wrapper > aside .list .item-title {
        margin: 10px;
    }

    .body-wrapper > aside .list .item-ul {
        margin-left: 10px;
    }

    .body-wrapper > aside .list .icon-unit {
        display: inline-block;

    }

    .body-wrapper > aside .list .icon-unit img {
        cursor: pointer;
    }

    .body-wrapper > aside .list .icon-unit div {
        display: flex;
        justify-content: center;
    }

    .body-wrapper > aside .list ul li {
        display: inline;
        list-style-type: none;
    }

    .body-wrapper > aside .list .icon-content {
        height: 60px;
        border: 1px solid black;
        border-radius: 4px;
    }

    .body-wrapper > main {
        margin-left: 20px;
        flex: 1;
        background-color: lightgray;
        border-radius: 10px;
    }

    /*操作规范，参见：chap7、svg元素拖动*/

    /*不可编辑状态*/
    #plotBoard .edit-inactive {
        cursor: pointer;
    }

    #plotBoard .edit-inactive .control-group {
        display: none;
    }

    /*可编辑状态*/
    #plotBoard .edit-active {
        cursor: move;
    }

    #plotBoard .edit-active .control-group .control-scale-item-1 {
        cursor: w-resize;
        /*cursor:url("http://ued.taobao.com/blog/wp-content/themes/taobaoued/images/cursor.ico") ,auto;*/
    }

    #plotBoard .edit-active .control-group .control-scale-item-2 {
        cursor: s-resize;
    }

    #plotBoard .edit-active .control-group .control-scale-item-3 {
        cursor: ne-resize;
    }

    #plotBoard .edit-active .control-group .control-scale-item-4 {
        cursor: se-resize;
    }

    #plotBoard .edit-active .control-group .control-rotate-item {
        cursor: crosshair;
        fill: yellow;
        /*cursor: url("rotate.ico"), auto;*/

    }
</style>
</body>

</html>